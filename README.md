# ИДЗ по ОС №1 / Вариант №9
## Васильев Андрей Михайлович / БПИ215

Работа выполнена с соблюдением всех критериев на **8 БАЛЛОВ**.

Входные файлы, на которых проводились тесты, расположены в корне проекта - `input{i}`.
Результаты тестов для каждой программы на соответствующий балл расположены в директории `test_results/{n}`, где `n` - номер программы (балл).


## Условие задачи

Разработать программу, которая «переворачивает на месте» заданную ASCII-строку символов (не копируя строку в другой буфер).

## 4 балла

```bash
gcc 4.c utils.c reverse.c
./a.out input1 output1
cat output1
```
В этой программе все просто. Открываем один пайп, который делят между собой три процесса.
Первый (родительский) процесс считает данные из файла и запишет их в пайп. Второй процесс считает данные из пайпа, вызовет функцию обработки (reverse) и запишет результат в пайп. При обработке не выделяется память для новой результирующей строки, как и сказано в условии задачи. Вместо этого изменяется переданная строка. Третий процесс считает результат работы из пайпа и запишет его в файл.

## 5 баллов

```bash
gcc 5.c utils.c reverse.c
./a.out input1 output1
cat output1
```

В этой программе суть та же, что и в четвертой, но используем именованные каналы. Схема такая:
1. Создаем два именованных канала `5_1.fifo` и `5_2.fifo` (используя функцию `mkfifo()`)
2. Первый процесс считывает строку из файла и записывает ее в канал `5_1.fifo`
3. Второй процесс считывает строку из канала `5_1.fifo`, вызывает для нее функцию обработки (reverse) и записывает результат в канал `5_2.fifo`
4. Третий процесс считывает результат из канала `5_2.fifo` и записывает его в файл

## 6 баллов

```bash
gcc 6.c utils.c reverse.c
./a.out input1 output1
cat output1
```

В этой программе делаем немного по-другому - процессов теперь два. Вот схема:
1. Создаем два пайпа
2. Первый процесс считывает строку из файла и записывает ее в первый пайп
3. Второй процесс считывает строку из первого пайпа, вызывает для нее функцию обработки (reverse) и записывает результат во второй пайп
4. Первый процесс считывает результат из второго пайпа и записывает его в файл

## 7 баллов

```bash
gcc 7.c utils.c reverse.c
./a.out input1 output1
cat output1
```

Процесс аналогичен программе 6, но используем именованные каналы. Вот схема:
1. Создаем два именованных канала `7_1.fifo` и `7_2.fifo` (используя функцию `mkfifo()`)
2. Первый процесс считывает строку из файла и записывает ее в канал `7_1.fifo`
3. Второй процесс считывает строку из канала `7_1.fifo`, вызывает для нее функцию обработки (reverse) и записывает результат во второй канал `7_2.fifo`
4. Первый процесс считывает результат из канала `7_2.fifo` и записывает его в файл

## 8 баллов

```bash
gcc 8_1.c utils.c reverse.c -o first_process
./first_process input1 output1
cat output1
```

```bash
gcc 8_2.c utils.c reverse.c -o second_process
./second_process
```

Все то же самое, что и в программе 7, но используем неродственные процессы. Вот схема:
1. Создаем два именованных канала `8_1.fifo` и `8_2.fifo` (используя функцию `mkfifo()`)
2. Первый процесс считывает строку из файла и записывает ее в канал `8_1.fifo`
3. Второй процесс считывает строку из канала `8_1.fifo`, вызывает для нее функцию обработки (reverse) и записывает результат во второй канал `7_2.fifo`
4. Первый процесс считывает результат из канала `8_2.fifo` и записывает его в файл